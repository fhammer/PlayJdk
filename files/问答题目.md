#### 实现多线程有哪些方式？有什么异同？
1. 继承Thread
2. 实现Runnable
3. Callable(JDK1.5 以后)
多线程的两种实现方式的区别：
 　　1.Thread是Runnable接口的子类，实现Runnable接口的方式解决了Java单继承的局限
 　　2.Runnable接口实现多线程比继承Thread类更加能描述数据共享的概念
注意：通过实现Runnable接口解决了Java单继承的局限，所以不管其他的区别联系是什么，这一点就决定了多线程最好是通过实现Runnable接口的方式
补充: 我并不认为第二和第三种是实现线程的方式，因为归根结底是要在Thread或者其子类中执行的任务。

#### 线程的生命周期
① 新建状态(New Thread)：在Java语言中使用new 操作符创建一个线程后，该线程仅仅是一个空对象，它具备类线程的一些特征，但此时系统没有为其分配资源，这时的线程处于创建状态。

线程处于创建状态时，可通过Thread类的方法来设置各种属性，如线程的优先级(setPriority)、线程名(setName)和线程的类型(setDaemon)等。

② 就绪状态(Runnable)：使用start()方法启动一个线程后，系统为该线程分配了除CPU外的所需资源，使该线程处于就绪状态。此外，如果某个线程执行了yield()方法，那么该线程会被暂时剥夺CPU资源，重新进入就绪状态。

③ 运行状态(Running)：Java运行系统通过调度选中一个处于就绪状态的线程，使其占有CPU并转为运行状态。此时，系统真正执行线程的run()方法。

a)     可以通过Thread类的isAlive方法来判断线程是否处于就绪/运行状态：当线程处于就绪/运行状态时，isAlive返回true，当isAlive返回false时，可能线程处于阻塞状态，也可能处于停止状态。

④ 阻塞和唤醒线程

阻塞状态(Blocked)：一个正在运行的线程因某些原因不能继续运行时，就进入阻塞 状态。这些原因包括：

     a) 当执行了某个线程对象的sleep()等阻塞类型的方法时，该线程对象会被置入一个阻塞集内，等待超时而自动苏醒。

     b) 当多个线程试图进入某个同步区域时，没能进入该同步区域的线程会被置入锁定集，直到获得该同步区域的锁，进入就绪状态。

     c) 当线程执行了某个对象的wait()方法时，线程会被置入该对象的等待集中，知道执行了该对象的notify()方法wait()/notify()方法的执行要求线程首先获得该对象的锁。

⑤ 死亡状态(Dead)：线程在run()方法执行结束后进入死亡状态。此外，如果线程执行了interrupt()或stop()方法，那么它也会以异常退出的方式进入死亡状态。

#### 终止线程的三种方法

① 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止，推荐使用。

② 使用stop方法强制终止线程(这个方法不推荐使用，因为stop和suppend、resume一样，也可能发生不可预料的结果)。

③ 使用interrupt方法中断线程。

#### Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别
 sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复
 wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。

#### sleep()与yield()区别
 sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；
 sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；
 sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性

#### 内存溢出有些类型，如何解决
内存溢出的类型主要和运行时数据区类型有关，能发生内存溢出的区域主要有方法区，堆区，线程栈区。
第一种OutOfMemoryError： PermGen space(方法区也叫永久代) 发生这种问题的原因是程序中使用了大量的jar或class，使java虚拟机装载类的空间不够，与Permanent Generation space有关。解决这类问题有以下两种办法： 1. 增加java虚拟机中的XX:PermSize和XX:MaxPermSize参数的大小，其中XX:PermSize是初始永久保存区域大小，XX:MaxPermSize是最大永久保存区域大小。如针对tomcat6.0，在catalina.sh 或catalina.bat文件中一系列环境变量名说明结束处（大约在70行左右） 增加一行： JAVA_OPTS=" -XX:PermSize=64M -XX:MaxPermSize=128m" 如果是windows服务器还可以在系统环境变量中设置。感觉用tomcat发布sprint+struts+hibernate架构的程序时很容易发生这种内存溢出错误。使用上述方法，我成功解决了部署ssh项目的tomcat服务器经常宕机的问题。 2. 清理应用程序中web-inf/lib下的jar，如果tomcat部署了多个应用，很多应用都使用了相同的jar，可以将共同的jar移到tomcat共同的lib下，减少类的重复加载。这种方法是网上部分人推荐的，我没试过，但感觉减少不了太大的空间，最靠谱的还是第一种方法。
第二种OutOfMemoryError： Java heap space 发生这种问题的原因是java虚拟机创建的对象太多，在进行垃圾回收之前，虚拟机分配的到堆内存空间已经用满了，与Heap space有关。解决这类问题有两种思路： 1. 检查程序，看是否有死循环或不必要地重复创建大量对象。找到原因后，修改程序和算法。 我以前写一个使用K-Means文本聚类算法对几万条文本记录（每条记录的特征向量大约10来个）进行文本聚类时，由于程序细节上有问题，就导致了Java heap space的内存溢出问题，后来通过修改程序得到了解决。 2. 增加Java虚拟机中Xms（初始堆大小）和Xmx（最大堆大小）参数的大小。如：set JAVA_OPTS= -Xms256m -Xmx1024m
第三种OutOfMemoryError：unable to create new native thread 这种错误在Java线程个数很多的情况下容易发生

#### 垃圾回收器有哪些
 串行垃圾回收器（Serial Garbage Collector）
     串行垃圾回收器通过持有应用程序所有的线程进行工作。它为单线程环境设计，只使用一个单独的线程进行垃圾回收，通过冻结所有应用程序线程进行工作，所以可能不适合服务器环境。它最适合的是简单的命令行程序。
     
     通过JVM参数-XX:+UseSerialGC可以使用串行垃圾回收器。
     
 并行垃圾回收器（Parallel Garbage Collector）
     并行垃圾回收器也叫做 throughput collector 。它是JVM的默认垃圾回收器。与串行垃圾回收器不同，它使用多线程进行垃圾回收。相似的是，它也会冻结所有的应用程序线程当执行垃圾回收的时候
     
 并发标记扫描垃圾回收器（CMS Garbage Collector）
     并发标记垃圾回收使用多线程扫描堆内存，标记需要清理的实例并且清理被标记过的实例。并发标记垃圾回收器只会在下面两种情况持有应用程序所有线程。
     
     当标记的引用对象在tenured区域；
     在进行垃圾回收的时候，堆内存的数据被并发的改变。
     相比并行垃圾回收器，并发标记扫描垃圾回收器使用更多的CPU来确保程序的吞吐量。如果我们可以为了更好的程序性能分配更多的CPU，那么并发标记上扫描垃圾回收器是更好的选择相比并发垃圾回收器。
     
     通过JVM参数 XX:+USeParNewGC 打开并发标记扫描垃圾回收器。
     
 G1垃圾回收器（G1 Garbage Collector）
     G1垃圾回收器适用于堆内存很大的情况，他将堆内存分割成不同的区域，并且并发的对其进行垃圾回收。G1也可以在回收内存之后对剩余的堆内存空间进行压缩。并发扫描标记垃圾回收器在STW情况下压缩内存。G1垃圾回收会优先选择第一块垃圾最多的区域
     
     通过JVM参数 –XX:+UseG1GC 使用G1垃圾回收器
     
     
#### 什么情况下会出现Full GC，什么情况下会出现Young GC
 对象优先在新生代Eden区中分配，如果Eden区没有足够的空间时，就会触发一次young gc
 Full gc的触发条件有多个，FULL GC的时候会STOP THE WORD。
 在执行Young gc之前，JVM会进行空间分配担保——如果老年代的连续空间小于新生代对象的总大小（或历次晋升的平均大小），则触发一次full gc。
 显式调用System.gc()方法时；
 大对象直接进入老年代，从年轻代晋升上来的老对象，尝试在老年代分配内存时，但是老年代内存空间不够；

#### JVM如何加载字节码文件
 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。
 
 Java语言中类的加载、连接和初始化过程都是在程序运行期间完成的，领Java具备高度的灵活性。
 类加载的过程：加载、连接（验证、准备、解析）、初始化。
 加载：通过一个类的名字获取此类的二进制字节流（PS：不限于从文件中读取）；将这个字节流代表的静态存储结构转换为方法区的运行时结构（由具体的虚拟机自己定义）；在内存中生成一个java.lang.Class对象，作为方法区这个类的各种数据结构的访问入口。
 验证：文件格式验证、元数据验证（语义分析，类与类的继承关系等）、字节码验证（数据流和控制流分析）、符号引用验证（对类自身以外的信息进行匹配校验）
 准备：正式为类变量分配内存并设置初始值，这里类变量指的是被static修饰的变量。例外：如果类字段是常量，则在这里会被初始化为表达式指定的值。
 解析：将常量池内的符号引用替换为直接引用。符号引用：类似于OS中的逻辑地址；直接引用：类似于OS中的物理地址，直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄。
 初始化：真正开始执行类中定义的Java程序代码；初始化用于执行Java类的构造方法。类初始化的过程是不可逆的，如果中间一步出错，则无法执行下一步，参见不可逆的类初始化过程。

#### Java内存模型是什么
 Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了：

 线程内的代码能够按先后顺序执行，这被称为程序次序规则。

 对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。

 前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。

 一个线程内的任何操作必需在这个线程的start()调用之后，也叫作线程启动规则。

 一个线程的所有操作都会在线程终止之前，线程终止规则。

 一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。

可传递性

#### Java中活锁和死锁有什么区别
 活锁：一个线程通常会有会响应其他线程的活动。如果其他线程也会响应另一个线程的活动，那么就有可能发生活锁。同死锁一样，发生活锁的线程无法继续执行。然而线程并没有阻塞——他们在忙于响应对方无法恢复工作。这就相当于两个在走廊相遇的人：甲向他自己的左边靠想让乙过去，而乙向他的右边靠想让甲过去。可见他们阻塞了对方。甲向他的右边靠，而乙向他的左边靠，他们还是阻塞了对方。

 死锁：两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候，死锁会让你的程序挂起无法完成任务。


#### 如何避免死锁？
死锁的发生必须满足以下四个条件：

互斥条件：一个资源每次只能被一个进程使用。

请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。

循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

三种用于避免死锁的技术：

加锁顺序（线程按照一定的顺序加锁）

加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）


#### 重载（Overload）和重写（Override）的区别
 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间
 
 【重写】两同两小一大原则
 两同：方法名相同；形参列表相同
 两小：子类方法返回值类型应比父类方法返回值类型更小或相等；
 子类方法声明抛出的异常应比父类方法声明抛出的异常类更小或相等
 一大：子类权限比父类大或相等
 
#### 抽象类和接口异同
 抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。
 接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。

####  Error和Exception
 Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；
 
 Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。
 *RuntimeException运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。
 常见：
 ArithmeticException（算术异常）
 ClassCastException （类转换异常）
 IllegalArgumentException （非法参数异常）
 IndexOutOfBoundsException （下标越界异常）
 NullPointerException （空指针异常）
 SecurityException （安全异常）
 
 受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在Effective Java中对异常的使用给出了以下指导原则：
 
 不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常）
 对可以恢复的情况使用受检异常，对编程错误使用运行时异常
 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）
 优先使用标准的异常
 每个方法抛出的异常都要有文档
 保持异常的原子性
 不要在catch中忽略掉捕获到的异常

#### synchronized 和java.util.concurrent.locks.Lock的异同
 Lock是Java 5以后引入的新的API，和关键字synchronized相比主要相同点：Lock 能完成synchronized所实现的所有功能；
 
 主要不同点：
 Lock有比synchronized更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。
 synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且最好在finally 块中释放（这是释放外部资源的最好的地方）
 
#### Statement和PreparedStatement有什么区别？哪个性能更好
 与Statement相比，PreparedStatement接口代表预编译的语句，它主要的优势在于：
 
 可以减少SQL的编译错误并增加SQL的安全性（减少SQL注射攻击的可能性）；
 PreparedStatement中的SQL语句是可以带参数的，避免了用字符串连接拼接SQL语句的麻烦和不安全；
 当批量处理SQL或频繁执行相同的查询时，PreparedStatement有明显的性能上的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）

#### GC Roots都有哪些： 
     1. 虚拟机栈中的引用的对象 
     2. 方法区中静态属性引用的对象，常量引用的对象 
     3. 本地方法栈中JNI（即一般说的Native方法）引用的对象

#### Volatile和Synchronized四个不同点： 
     1 粒度不同，前者针对变量 ，后者锁对象和类 
     2 syn阻塞，volatile线程不阻塞 
     3 syn保证三大特性，volatile不保证原子性 
     4 syn编译器优化，volatile不优化 
     
#### volatile具备两种特性： 
     1. 保证此变量对所有线程的可见性，指一条线程修改了这个变量的值，新值对于其他线程来说是可见的，但并不是多线程安全的。 
     2. 禁止指令重排序优化。 
     Volatile如何保证内存可见性: 
     1.当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。 
     2.当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。
     
     同步：就是一个任务的完成需要依赖另外一个任务，只有等待被依赖的任务完成后，依赖任务才能完成。 
     异步：不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，只要自己任务完成了就算完成了，被依赖的任务是否完成会通知回来。（异步的特点就是通知）。 
     打电话和发短信来比喻同步和异步操作。 
     阻塞：CPU停下来等一个慢的操作完成以后，才会接着完成其他的工作。 
     非阻塞：非阻塞就是在这个慢的执行时，CPU去做其他工作，等这个慢的完成后，CPU才会接着完成后续的操作。 
     非阻塞会造成线程切换增加，增加CPU的使用时间能不能补偿系统的切换成本需要考虑。

#### 索引：B+，B-,全文索引 
Mysql的索引是一个数据结构，旨在使数据库高效的查找数据。 
常用的数据结构是B+Tree，每个叶子节点不但存放了索引键的相关信息还增加了指向相邻叶子节点的指针，这样就形成了带有顺序访问指针的B+Tree，做这个优化的目的是提高不同区间访问的性能。 
什么时候使用索引： 
1. 经常出现在group by,order by和distinc关键字后面的字段 
2. 经常与其他表进行连接的表，在连接字段上应该建立索引 
3. 经常出现在Where子句中的字段 
4. 经常出现用作查询选择的字段


#### Servlet和Filter的区别： 
     整的流程是：Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理。
     
     Filter有如下几个用处： 
     Filter可以进行对特定的url请求和相应做预处理和后处理。 
     在HttpServletRequest到达Servlet之前，拦截客户的HttpServletRequest。 
     根据需要检查HttpServletRequest，也可以修改HttpServletRequest头和数据。 
     在HttpServletResponse到达客户端之前，拦截HttpServletResponse。 
     根据需要检查HttpServletResponse，也可以修改HttpServletResponse头和数据。
     
     实际上Filter和Servlet极其相似，区别只是Filter不能直接对用户生成响应。实际上Filter里doFilter()方法里的代码就是从多个Servlet的service()方法里抽取的通用代码，通过使用Filter可以实现更好的复用。
     
     Filter和Servlet的生命周期： 
     1.Filter在web服务器启动时初始化 
     2.如果某个Servlet配置了 1 ，该Servlet也是在Tomcat（Servlet容器）启动时初始化。 
     3.如果Servlet没有配置1 ，该Servlet不会在Tomcat启动时初始化，而是在请求到来时初始化。 
     4.每次请求， Request都会被初始化，响应请求后，请求被销毁。 
     5.Servlet初始化后，将不会随着请求的结束而注销。 
     6.关闭Tomcat时，Servlet、Filter依次被注销。
     
#### 抽象类和接口的区别
     
     a.一个类只能继承单个类，但是可以实现多个接口
     
     b.抽象类中可以有构造方法，接口中不能有构造方法
     
     c.抽象类中的所有方法并不一定要是抽象的，你可以选择在抽象类中实现一些基本的方法。而接口要求所有的方法都必须是抽象的
     
     d.抽象类中可以包含静态方法，接口中不可以
     
     e.抽象类中可以有普通成员变量，接口中不可以