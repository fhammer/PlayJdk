#### 实现多线程有哪些方式？有什么异同？
1. 继承Thread
2. 实现Runnable
3. Callable(JDK1.5 以后)
多线程的两种实现方式的区别：
 　　1.Thread是Runnable接口的子类，实现Runnable接口的方式解决了Java单继承的局限
 　　2.Runnable接口实现多线程比继承Thread类更加能描述数据共享的概念
注意：通过实现Runnable接口解决了Java单继承的局限，所以不管其他的区别联系是什么，这一点就决定了多线程最好是通过实现Runnable接口的方式
补充: 我并不认为第二和第三种是实现线程的方式，因为归根结底是要在Thread或者其子类中执行的任务。

#### 线程的生命周期
① 新建状态(New Thread)：在Java语言中使用new 操作符创建一个线程后，该线程仅仅是一个空对象，它具备类线程的一些特征，但此时系统没有为其分配资源，这时的线程处于创建状态。

线程处于创建状态时，可通过Thread类的方法来设置各种属性，如线程的优先级(setPriority)、线程名(setName)和线程的类型(setDaemon)等。

② 就绪状态(Runnable)：使用start()方法启动一个线程后，系统为该线程分配了除CPU外的所需资源，使该线程处于就绪状态。此外，如果某个线程执行了yield()方法，那么该线程会被暂时剥夺CPU资源，重新进入就绪状态。

③ 运行状态(Running)：Java运行系统通过调度选中一个处于就绪状态的线程，使其占有CPU并转为运行状态。此时，系统真正执行线程的run()方法。

a)     可以通过Thread类的isAlive方法来判断线程是否处于就绪/运行状态：当线程处于就绪/运行状态时，isAlive返回true，当isAlive返回false时，可能线程处于阻塞状态，也可能处于停止状态。

④ 阻塞和唤醒线程

阻塞状态(Blocked)：一个正在运行的线程因某些原因不能继续运行时，就进入阻塞 状态。这些原因包括：

     a) 当执行了某个线程对象的sleep()等阻塞类型的方法时，该线程对象会被置入一个阻塞集内，等待超时而自动苏醒。

     b) 当多个线程试图进入某个同步区域时，没能进入该同步区域的线程会被置入锁定集，直到获得该同步区域的锁，进入就绪状态。

     c) 当线程执行了某个对象的wait()方法时，线程会被置入该对象的等待集中，知道执行了该对象的notify()方法wait()/notify()方法的执行要求线程首先获得该对象的锁。

⑤ 死亡状态(Dead)：线程在run()方法执行结束后进入死亡状态。此外，如果线程执行了interrupt()或stop()方法，那么它也会以异常退出的方式进入死亡状态。

#### 终止线程的三种方法

① 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止，推荐使用。

② 使用stop方法强制终止线程(这个方法不推荐使用，因为stop和suppend、resume一样，也可能发生不可预料的结果)。

③ 使用interrupt方法中断线程。